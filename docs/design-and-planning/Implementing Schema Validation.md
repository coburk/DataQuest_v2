## ðŸš§ Implementing Schema Validation

The **Schema Validation** component is a crucial part of the **SQL Enforcer Agent (US-08)** and the  **Case Manager** . Its primary function is to act as a **logic safety net** by verifying that the data structures and relationships assumed by the `CasePlan`â€”and its canonical SQLâ€”are correct and present in the actual database schema. This prevents "broken" cases from reaching the student.

---

### 1. Schema Validation Goals and Triggers

| **Goal**              | **Description**                                                                                                           | **Trigger Point**                                                             |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Integrity Check**   | Ensure the tables and columns referenced in the `CanonicalQuery`strings actually exist in the live SQL database.              | **Case Generation (US-07):**After the Case Planner creates a case.                  |
| **Consistency Check** | Verify all Foreign Key (FK) relationships essential to the case narrative are correctly defined and populated.                  | **Case Loading Pipeline:**Before a case is presented to the student.                |
| **Logic Check**       | Detect logical contradictions between different data entities (e.g., conflicting timestamps, contradictory witness statements). | **Case Generation (US-08):**As part of the SQL Enforcer's solvability verification. |

---

### 2. Validation Workflow and Execution

The **Schema Validation** process is integrated directly into the  **SQL Enforcer** 's larger solvability check during Phase 1 of the Case Lifecycle.

#### A. Data Retrieval (Via DB Agent)

1. **Request Live Schema:** The **SQL Enforcer** requests the current database schema structure (tables, columns, FKs) from the  **Database Agent** , which uses the `schema.describe` MCP tool.
2. **Case Reference Extraction:** The Enforcer parses the `CanonicalQuery` strings within the `CasePlan`'s `StorySteps` to identify all referenced table and column names.

#### B. Consistency and Existence Checks

3. **Table/Column Existence Check:** The Enforcer compares the referenced names (from Step 2) against the live schema (from Step 1).
   * **Failure:** If a canonical query references a table or column that  **does not exist** , the case is immediately rejected. This prevents SQL errors during the Query Tutor's verification step.
4. **Foreign Key (FK) Integrity Check:** For any `JOIN` operations implied in the canonical SQL, the Enforcer verifies that the required FK constraint exists in the schema and, more critically, that the **data itself adheres to the constraint** (no orphaned records).
5. **Contradiction Detection (US-08a):** The Enforcer runs pre-defined, rule-based queries against the data to check for story-breaking logical inconsistencies.
   * *Example Query:* "Select all rows in `WitnessStatements` where the reported time falls outside the time range of events recorded in `TransactionLogs`." If this query returns results, a contradiction is flagged.

#### C. Output and Action

6. **Final Verdict:** Based on the results of all checks, the Enforcer sets the **`IsSolvable`** flag in the `CasePlan` to `true` or `false`.
7. **Logging:** A **"Case Validation Summary"** is generated, detailing any failed checks for debugging purposes.
8. **Action:**
   * **If Validation Fails:** The `CasePlan` is rejected, preventing it from being stored or loaded by the `CaseManager`.
   * **If Validation Passes:** The case is finalized and made available for students.

This robust validation process ensures the DataQuest environment remains a trustworthy and reliable learning tool, protecting students from frustrating, unsolvable mysteries generated by the probabilistic nature of the underlying LLM.
