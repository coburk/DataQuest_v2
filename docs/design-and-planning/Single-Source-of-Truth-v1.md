Here is the Single Source of Truth (SSOT) document for DataQuest: SQL Detective. This document aggregates the core design decisions, architecture, and specifications into one centralized reference.
________________________________________
DataQuest: SQL Detective — Single Source of Truth (SSOT)
•	Version: 1.0 
•	Status: Phase 1 Implementation Ready
•	Primary Tech Stack: C# .NET 9, WinForms, Microsoft SQL Server, Ollama (Local LLM), Model Context Protocol (MCP).
________________________________________
1. Project Epic & Executive Summary
DataQuest: SQL Detective is an AI-assisted learning application designed to transform SQL education into a dynamic, gamified investigative experience. By shifting the perception of SQL from a rigid programming language to a forensic tool, students operate as lead detectives solving narrative-based mysteries.
The system utilizes a local, multi-agent AI architecture to generate cases, validate logic, and provide Socratic tutoring, ensuring privacy and offline capability for classroom environments.
________________________________________
2. Problem, Purpose, & Objectives
The Problem
Traditional SQL education often focuses on syntax memorization, resulting in students who can write queries but lack critical thinking and data reasoning skills. Learners struggle to connect technical proficiency with real-world problem-solving.
The Purpose
To bridge the gap between technical skill and analytical thinking by creating an environment where every SQL query is a question asked of the evidence. The system frames learning as an investigation: Plan (the inquiry), Verify (the execution), and Tutor (the feedback).
Core Objectives
1.	Develop an AI-driven platform that turns query practice into interactive investigations.
2.	Implement 4 specialized AI Agents (Database Agent, Case Planner Agent, Query Tutor Agent, SQL Enforcer Agent).
3.	Integrate the Model Context Protocol (MCP) for secure, read-only database access.
4.	Gamify Learning through narrative "cases" rather than abstract problem sets.
5.	Deliver Socratic Tutoring that guides reasoning rather than providing direct answers.
________________________________________
3. Architecture Overview
High-Level Architecture
DataQuest utilizes a modular, layered architecture designed for local execution.
•	Presentation Layer: C# WinForms UI (Schema Browser, SQL Editor, Results Grid, Hint Panel).
•	Application Layer: Contains the AgentOrchestrator (traffic controller for AI) and CaseManager (state management).
•	AI Agent Layer: Four specialized agents that interface with the backend.
•	Infrastructure Layer: 
o	OllamaInterface: Manages local LLM inference.
o	MCP Client: Manages JSON-RPC communication.
o	Local Backend: MSSQL Database and C# MCP Server.
System Context
The application sits between the Student and the Local Infrastructure. The Agent Orchestrator manages the flow of data between the User Interface and the AI Agents, routing requests to the Local LLM (for reasoning) or the Database MCP (for data retrieval).
________________________________________
4. AI Agent Definitions
The system relies on four core agents operating within a Plan-Verify-Tutor cycle.
Agent Name	Role	Core Responsibility
Case Planner Agent	The Storyteller	Analyzes schema to generate CasePlan JSON objects containing narrative steps and canonical queries. It does not validate its own work,.
SQL Enforcer Agent	The Logic Checker	Validates the solvability of cases generated by the Planner. It executes canonical queries to ensure data integrity and rejects broken cases,.
Query Tutor Agent	The Mentor	Compares student query results against canonical results. If the query fails, it generates Socratic, schema-grounded hints to guide the student,.
Database Agent	The Technical Expert	Translates raw database schema (tables, columns, foreign keys) into natural-language explanations to help students understand the data structure,.
________________________________________
5. Model Context Protocol (MCP) Overview
The MCP serves as the secure middleware between the AI Agents and the SQL Database.
•	Status: Integration Complete
•	Implementation: A custom C# server implementing JSON-RPC 2.0.
•	Security: Exposes only read-only capabilities to the agents, preventing accidental data corruption or hallucinated destructive commands.
Primary MCP Tools:
1.	schema.describe: Allows agents to inspect table structures.
2.	sql.execute_readonly: Allows agents to execute SELECT queries safely.
________________________________________
6. Database Schema
Design Decision: The system uses a Traditional Separate Tables approach. JSON and polymorphic designs are strictly hidden from the student view to ensure educational clarity.
Core Investigative Tables
•	Cases: Definition of the investigation scenario.
•	Persons: Suspects, witnesses, and victims involved in the case.
•	Locations: Physical places where evidence or events occur.
•	Evidence: Physical items linked to cases and locations.
Tier-Specific Tables (Progressive Complexity)
•	Tier 1: BadgeAccess, ParkingLotAccess (Simple SELECT/WHERE).
•	Tier 2: Incidents, CommunicationRecords (JOINs/Aggregation).
•	Tier 3: WitnessStatements (Data Quality/Contradictions).
•	Tier 4+: TransactionLogs (Complex Analysis).
Tutoring Control Tables (Hidden Logic)
•	StorySteps: Sequential narrative steps for the case.
•	AnswerKeys: Contains the ExpectedResultHash and CanonicalQuery used by the Tutor Agent to validate student success.
________________________________________
7. User Stories (Phase 1 MVP)
ID	Focus Area	Goal
US-01	Environment	Establish .NET 9, SQL Server, and Ollama environment.
US-02	Schema	Provide a Schema Browser for students to inspect tables.
US-03	Execution	Enable safe SQL execution via MCP with results grid.
US-04	DB Agent	AI explains schema in plain English to students.
US-05	Tutor Agent	Compare student results to canonical results.
US-06	Hints	Provide multi-level Socratic hints for stuck students.
US-07	Planner Agent	Auto-generate solvable investigation cases.
US-08	Enforcer Agent	Validate logical consistency of generated cases.
US-09	Stabilization	Code freeze, end-to-end testing, and demo prep.
US-10	Presentation	Final slide deck and demo delivery.
________________________________________
8. Timeline (Development Roadmap)
The project follows a 10-week sequential roadmap, delivering one User Story per week.
•	Weeks 1-3 (Infrastructure): Domain Models, Database Layer setup, MCP Server integration-.
•	Weeks 4-5 (Core Pipelines): Query Execution Pipeline, Schema Browser, Query Tutor comparison logic-.
•	Weeks 6-7 (Tutoring & Logic): Hint Generation Pipeline, Case Management, SQL Enforcer logic.
•	Weeks 8-9 (Integration): Full Agent Orchestration, UI Polish, End-to-End Testing-.
•	Week 10 (Finalizing): Documentation and Capstone Presentation.
________________________________________
9. Risks and Mitigations
Risk	Impact	Mitigation Strategy
Local LLM Performance	Slow response times or stalling.	Use optimized models (Llama 3.1 8B), cache schema descriptions, set strict timeouts.
MCP Complexity	Integration failure blocking agents.	Use proven C# SDK, prototype early (Week 2), isolate testing before agent integration.
AI Hallucination	Agents generating invalid SQL.	All AI output is validated by the SQL Enforcer before reaching the student; use read-only MCP tools.
Unsolvable Cases	Students stuck due to logic errors.	Strict IsSolvable validation by Enforcer; hard-code one fallback demo case.
Environment Drift	SQL Server version mismatches.	Provide a standardized .bak restore file and init-database.sql script.
________________________________________
10. Deployment Plan
The deployment strategy focuses on local, offline capability to mirror the student's existing course environment.
Deployment Artifacts
•	Database: DataQuest.bak or init-database.sql script.
•	Application: Self-contained .NET executable (DataQuest.exe).
•	AI Infrastructure: Local Ollama instance and compiled MCP Server binary.
Environment Strategy
•	Development: Local machine with full debugging tools.
•	Production (Student Laptop): Local installation. The app reads appsettings.json to connect to the local SQL instance.
•	Startup Sequence: Application validates DB connection $\rightarrow$ Checks MCP status $\rightarrow$ Verifies Ollama connectivity $\rightarrow$ Loads "Ready" state.

